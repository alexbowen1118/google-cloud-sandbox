# NC DPR

## Requirements

- Docker=20.10.17
- Docker-Compose=2.10.2

## Quick Start

### Secrets Management

To run the DPR stack, several secrets need to be installed into the project structure. These secrets are files that are placed under the `secrets/` directory and read into appropriate containers at run time. For securit purposes, these files are ignored by version control and must be configured at the local level before runtime. See the following table for a list of secrets:

| Filename              | Description                                                                                                                                                              | Example                                                               |
| --------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------- |
| domain.crt            | SSL certificate of the hostname you're using for the stack for https purposes.                                                                                           | `-----BEGIN CERTIFICATE----- ...`                                     |
| domain.key            | Encryption key used in for https.                                                                                                                                        | `-----BEGIN PRIVATE KEY----- ...`                                     |
| mysql_root            | Password for the MariaDB root user                                                                                                                                       | `password`                                                            |
| legacy_mysql_user     | User for the legacy stack to access                                                                                                                                      | `root`                                                                |
| legacy_mysql_password | Password for the MariaDB root user                                                                                                                                       | `password`                                                            |
| jwt_key.json          | JWT info to generate the JWT signature used to verify API JWT tokens. This symmetric key and metadata can be generated by JWT Key generators such as https://mkjwk.org/. | `{"kty": "oct","use": "sig","kid": "dprbackend_api_key","k":"fIG-...` |

### Run Commands

The compose stack is started with a call to Docker Compose and configured with an environment variable file. The root directory folder contains .env files that specify different run configurations such as dev and prod however, our current implementation just has a dev.env. Since it is in the This env file is specified in the command line call to docker compose. See example.env for an explanation of the different environment configuration options.

**Development**

```docker
docker compose --env-file dev.env up --build --force-recreate
docker compose --env-file dev.env up
```

- --force-recreate Forces the containers to be recreated from images rather than simple restarting the containers.
  \*\* --build Instructs compose to build the images from their Dockerfiles rather than recreating containers from images.

## Security

### User Authentication

Users credentials are stored in the user table in columns user and hash. When a user logs in the username and password they provide are sent to the /auth/token endpoint where they are verified usign PHP's `password_verify` function. This automatically parses the algorithm, cost, and salt information from the stored password hash, applies the same transformations to the provided password and compares the two.

### API JWT Flow

Once the user is authenticated, a JSON Web Token is generated for them. This JWT includes some basic claims that will later be used to authenticate backend requests. The JWT is signed using a cryptographic hash and a octet key stored in the backend that produces a unique signature that becomes part of the JWT. Should any of the claims be modified in the JWT, this cryptographic hash would no longer match and API requests would be refused. It's important to note that the JWT generated is signed but not encrypted. Thus, it's integrity can be verified but all of the claim information is essentially plain texgt and should not contain any sensitive information.

The JSON Web Token (JWT) includes the following claims:

```json
{
  "sub": <user>,
  "role": <role>
}
```

These claims, as well as a header are base64 encoded and packaged into the JWT format. The token is signed using a 2Kb octet key using HS256. This ensures that, should a client browser make modifications to the JWT, the signature will not longer match when provided to the backend API and malicious API requests will be ignored. To promote security in the browser, this JWT is split into its three parts and the header and payload are stored in regular cookies while the signature is stored using the HttpOnly attribute to prevent browser access and protect against cross-site request forgery (CSRF) attacks.

Upon logging in, the user's browser is instructed to store these cookies and they will be attached to any subsequent API requests in the header to verify requests.

The backend of dprcal implements a middleware layer to screen all requests for a valid JWT before processing the request further. Once the JWT is verified, a check is made to parse the user's role and compare it against the permissions specified in the `index.php` file.
